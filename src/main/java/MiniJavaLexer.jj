//compilation javacc MiniJavaLexer.jj
options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
  import saif.compiler.syntaxtree.*;
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)

// Insert a specification of a lexical analysis here. 
TOKEN : {        
	<INT: "int">
    |<VOID: "void">
    |<BOOLEAN: "boolean">
    |<FALSE: "false">
    |<TRUE: "true">
    |<STRING: "String">
    |<IF: "if">
    |<ELSE: "else">
    |<MAIN: "main">
    |<THIS: "this">
    |<NEW: "new">
    |<WHILE: "while">
    |<PUBLIC: "public">
    |<CLASS: "class">
    |<STATIC: "static">
    |<LENGTH: "length">
    |<RETURN: "return">
    |<EXTENDS: "extends">
    |<LPAREN: "(">
    |<RPAREN: ")">
	|<LBRACE: "{">
	|<RBRACE: "}">
	|<LBRACKET: "[">
	|<RBRACKET: "]">
	|<SEMICOLON: ";">
	|<COMMA: ",">
	|<EQUAL: "=">
	|<DOT: ".">
	|<PRINTLN: "System.out.println">		      
	|<AND: "&&">
	|<LESS: "<">
	|<PLUS: "+">
	|<MINUS: "-">
	|<TIMES: "*">
	|<NOT: "!">
    |< #DIGIT: ["0"-"9"] >
	|< #LETTER: ["A"-"Z"] | ["a"-"z"] >
	| < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT> | "_")* >
	| < INTEGER_LITERAL: (<DIGIT>)+ >
}

/* The regular expressions here will be skipped during lexical analysis: */
SKIP : {
	<"//" (<DIGIT> | <LETTER> | " ")* ("\n" | "\r" | "\r\n")>
	|<"/*" (<DIGIT> | <LETTER> | (" " | "\n" | "\r" | "\r\n"))* "*/">
	| " "
	| "\t"
	| "\n"
}

// The following is a simple grammar that will allow you
// to test the generated lexer.
/*
void Goal() :
{}
{
  ( MiniJavaToken() )*
  <EOF>
}

void MiniJavaToken():
{}
{
  "{" | "public" | "static" | "void" |
  "main" | "(" | "String"  | "[" | "]" | ")" | "}" | "extends" | ";"
  | "return" | "," | "int" | "boolean" | "=" | "if" | "else" | "while"
  | "System.out.println" | "&&" | "<" | "+" | "-" | "*" | "." |
  "length" | <INTEGER_LITERAL> | "true" | "false" | "this" | "new" |
  "!"
}
*/
//adding parser
void Program() :
{}
{
    MainClass() (ClassDecl())* <EOF>
}

//rule for main class
void MainClass() :
{}
{
    <CLASS> <IDENTIFIER> 
    <LBRACE> 
    	<PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LBRACKET> <RBRACKET> <IDENTIFIER> <RPAREN>
    	<LBRACE> 
    		(LOOKAHEAD(2) VarDecl())* (Statement())* 
    	<RBRACE> 
    <RBRACE>
}

void ClassDecl():
{}
{
	LOOKAHEAD(3) ClassDeclSimple()
	| ClassExtendsDeclaration()
}

//rule for class other than main
void ClassDeclSimple():
{}
{
    <CLASS> <IDENTIFIER> 
    <LBRACE> 
    	(VarDecl())* (MethodDecl())* 
    <RBRACE>
}

void ClassExtendsDeclaration():
{}
{
	<CLASS> <IDENTIFIER> <EXTENDS> <IDENTIFIER> 
	<LBRACE> 
		(VarDecl())* (MethodDecl())* 
	<RBRACE>
}

void VarDecl():
{}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDecl():
{}
{
    <PUBLIC> Type() <IDENTIFIER> <LPAREN> (FormalList())? <RPAREN>
    <LBRACE> 
    	(LOOKAHEAD(2) VarDecl())* 
    	(Statement())* 
    	<RETURN> Exp() <SEMICOLON> 
    <RBRACE>
}

void FormalList():
{}
{
	FormalParameter() (FormalRest())*
}

void FormalParameter():
{}
{
	Type() <IDENTIFIER>
}

void FormalRest():
{}
{
    <COMMA> FormalParameter()
}

void Type():
{}
{
    LOOKAHEAD(2) IntArrayType()
    | BooleanType()
    | IntegerType()
    | IdentifierType()
}

void IdentifierType():
{}
{
	<IDENTIFIER>
}

void IntArrayType():
{}
{
	<INT> <LBRACKET> <RBRACKET>
}

void BooleanType():
{}
{
	<BOOLEAN>
}

void IntegerType():
{}
{
	<INT>
}

void Statement():
{}
{
    Block()
    | LOOKAHEAD(2) AssignmentStatement() 
    | ArrayAssignmentStatement()
    | IfStatement()
    | WhileStatement()
    | PrintStatement()
}

void Block():
{}
{
	<LBRACE> (Statement())* <RBRACE>
}

void AssignmentStatement():
{}
{
    <IDENTIFIER> <EQUAL> Exp() <SEMICOLON>
}

void ArrayAssignmentStatement():
{}
{
	<IDENTIFIER> <LBRACKET> Exp() <RBRACKET> <EQUAL> Exp() <SEMICOLON>
}

void IfStatement():
{}
{
	<IF> <LPAREN> Exp() <RPAREN> 
		Statement() 
	<ELSE> Statement()
}

void WhileStatement():
{}
{
	<WHILE> <LPAREN> Exp() <RPAREN> 
		Statement()
}

void PrintStatement():
{}
{
	<PRINTLN> <LPAREN> Exp() <RPAREN> <SEMICOLON>
}

//Expression
Exp Exp():
{Exp exp;}
{
	LOOKAHEAD(3) exp = AndExpression()
	| LOOKAHEAD(3) exp = LessThanExpression()
	| LOOKAHEAD(3) exp = PlusExpression()
	| LOOKAHEAD(3) exp = MinusExpression()
	| LOOKAHEAD(3) exp = TimesExpression()
   	| LOOKAHEAD(3) exp = ArrayLookup()
   	| LOOKAHEAD(3) exp = ArrayLength()
   	| LOOKAHEAD(3) exp = Call()
   	| exp = PrimaryExpression()
   	{
   		return exp;
   	}
}

AndExpression AndExpression():
{Exp exp1, exp2;}
{
	exp1 = PrimaryExpression() <AND> exp2 = PrimaryExpression()
	{
		return new AndExpression(exp1, exp2);
	}
}

LessThanExpression LessThanExpression():
{Exp exp1, exp2;}
{
	exp1 = PrimaryExpression() <LESS> exp2 = PrimaryExpression()
	{
		return new LessThanExpression(exp1, exp2);
	}
}

PlusExpression PlusExpression():
{Exp exp1, exp2;}
{
	exp1 = PrimaryExpression() <PLUS> exp2 = PrimaryExpression()
	{
		return new PlusExpression(exp1, exp2);
	}
}

MinusExpression MinusExpression():
{Exp exp1, exp2;}
{
	exp1 = PrimaryExpression() <MINUS> exp2 = PrimaryExpression()
	{
		return new MinusExpression(exp1, exp2);
	}
}

TimesExpression TimesExpression():
{Exp exp1, exp2;}
{
	exp1 = PrimaryExpression() <TIMES> exp2 = PrimaryExpression()
	{
		return new TimesExpression(exp1, exp2);
	}
}

ArrayLookup ArrayLookup():
{Exp idExp, indexExp;}
{
    idExp = PrimaryExpression() <LBRACKET> indexExp = Exp() <RBRACKET>
    {
    	return new ArrayLookup(idExp, indexExp); 
    }
}

ArrayLength ArrayLength():
{Exp ex;}
{
	ex = PrimaryExpression() <DOT> <LENGTH>
	{
		return new ArrayLength(ex);
	}
}

Call Call():
{Exp ex; Token t; ExpList expList = null;}
{
    ex = PrimaryExpression() <DOT> t = <IDENTIFIER> <LPAREN> (expList = ExpList())? <RPAREN>
    {
    	Identifier id = new Identifier(t.image);
    	return new Call(ex, id, expList);
    }
}

ExpList ExpList(): 
{ExpList expList = new ExpList(); Exp exp;}
{
   exp = Exp() {expList.addElement(exp);} (exp = ExpRest() {expList.addElement(exp);})*
   {return expList;}
}

Exp ExpRest():
{Exp ex;}
{
    "," ex = Exp() {return ex;}
}
Exp PrimaryExpression():
{Exp exp;}
{
	exp = IntegerLiteral()    
    | exp = TrueLiteral()
    | exp = FalseLiteral()
    | exp = IdentifierExpression()
    | exp = ThisExpression()
    | LOOKAHEAD(2) exp = NewArray()
    | exp = NewObject()
    | exp = NotExpression()
    | exp = BracketExpression()
    {return exp;}
}

IntegerLiteral IntegerLiteral():
{Token t;}
{
	t = <INTEGER_LITERAL>
	{
		return new IntegerLiteral(Integer.parseInt(t.image));
	}
}

TrueLiteral TrueLiteral():
{}
{
	<TRUE>
	{
		return new TrueLiteral();
	}
}

FalseLiteral FalseLiteral():
{}
{
	<FALSE>
	{
		return new FalseLiteral();
	}
}

IdentifierExpression IdentifierExpression():
{Token t;}
{
	t=<IDENTIFIER>
	{
		return new IdentifierExpression(t.image);
	}
}

ThisExpression ThisExpression():
{}
{
	<THIS>
	{
		return new ThisExpression();
	}
}

NewArray NewArray():
{Exp exp;}
{
	<NEW> <INT> <LBRACKET> exp = Exp() <RBRACKET>
	{
		return new NewArray(exp);
	}
}

NewObject NewObject():
{NewObject obj; Token t; Identifier id;}
{
	<NEW> t = <IDENTIFIER> <LPAREN> <RPAREN>
	{id = new Identifier(t.image);
	 obj = new NewObject(id);
	 return obj;	
	}
}

NotExpression NotExpression():
{Exp exp;}
{
	<NOT> exp = Exp()
	{return new NotExpression(exp);}
}

Exp BracketExpression():
{Exp ex;}
{
	<LPAREN> ex = Exp() <RPAREN>
	{return ex;}
}